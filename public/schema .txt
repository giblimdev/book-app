generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

////////////////////////////////
/////      AUTH MODELS     /////
////////////////////////////////  

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  sessions      Session[]
  accounts      Account[]
  
  // Relations avec les livres
  authoredBooks Book[]       @relation("AuthorBooks")
  bookNodes     BookNode[]   @relation("BookNodeAuthors")
  comments      Comment[]
  
  // Relations avec les fichiers
  files         File[]       @relation("UserFiles")
  
  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("accounts")
}

model Verification {
  id         String    @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@map("verifications")
}

////////////////////////////////
/////      BOOK MODELS     /////
////////////////////////////////

model Book {
  id          String    @id @default(cuid())
  title       String
  description String?
  image       String?
  order       Int       @default(0)
  
  // Relations
  author    User      @relation("AuthorBooks", fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  
  bookNodes BookNode[]
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("books")
}

model BookNode {
  id           String        @id @default(cuid())
  title        String
  description  String?
  type         String        @default("CHAPTER") // BOOK, PART, CHAPTER, SECTION, SUBSECTION, ARTICLE
  order        Int           @default(0)
  
  // Hiérarchie
  parentId     String?
  parent       BookNode?     @relation("Hierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children     BookNode[]    @relation("Hierarchy")
  
  // Auteurs (many-to-many)
  authors      User[]        @relation("BookNodeAuthors")
  
  // Contenu
  contents     NodeContent[]
  
  // Commentaires
  comments     Comment[]
  
  // Image
  imageId      String?
  image        Image?        @relation(fields: [imageId], references: [id], onDelete: SetNull)
  
  // Livre parent
  bookId       String?
  book         Book?         @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  // Métadonnées
  isPublished  Boolean       @default(false)
  publishedAt  DateTime?
  
  // Timestamps
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  
  @@map("book_nodes")
}

model NodeContent {
  id        String   @id @default(cuid())
  order     Int      @default(0)
  type      String   @default("TEXT") // TEXT, IMAGE, VIDEO, AUDIO, CODE, QUOTE, WARNING, INFO, TIP, QUESTION, EXERCISE, SOLUTION, TABLE, LIST
  content   String   @default("a rédiger")
  metadata  Json?    @default("{}")
  imageId   String?
  image     Image?   @relation(fields: [imageId], references: [id], onDelete: SetNull)
  
  // Relations
  nodeId    String
  node      BookNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("node_contents")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  isEdited  Boolean  @default(false)
  
  // Relations
  nodeId String
  node   BookNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  
  userId String
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("comments")
}

model Image {
  id        String    @id @default(cuid())
  url       String
  altText   String?
  width     Int?
  height    Int?
  format    String?   // jpg, png, webp, etc.
  
  // Relations
  bookNodes   BookNode[]
  nodeContent NodeContent[]
  
  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  @@map("images")
}

///////////////////////////////
/////     FILES MODELS    /////
///////////////////////////////

model File {
  id        String    @id @default(cuid())
  name      String
  slug      String    @unique
  order     Int       @default(0)
  type      String    @default("FILE") // FILE, FOLDER
  category  String?   // PAGE, COMPONENT, LAYOUT, HOOK, UTIL, LIB, STYLE, ASSET, CONFIG, DOCUMENTATION, TEST
  url       String?
  content   String?   // contenu du fichier (code, texte, etc.)
  role      String?   // rôle dans l'application
  relation  String?   // ID de l'entité liée
  mimeType  String?
  size      Int?      // taille en bytes
  isPublic  Boolean   @default(false)
  
  // Hiérarchie
  parentId  String?
  parent    File?     @relation("FileHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  File[]    @relation("FileHierarchy")
  
  userId    String?
  user      User?     @relation("UserFiles", fields: [userId], references: [id], onDelete: Cascade)

  // Métadonnées
  metadata  Json?     @default("{}")
  
  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  @@map("files")
}